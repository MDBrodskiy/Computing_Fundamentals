%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Written By Michael Brodskiy
% Class: Computing Fundamentals
% Professor: M. Fanaei
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\include{Includes.tex}

\title{Introduction to Computing Fundamentals}
\date{\today}
\author{Michael Brodskiy\\ \small Professor: M. Fanaei}

\begin{document}

\maketitle

\begin{itemize}

  \item An algorithm is a sequence of instructions that solve a well-defined computational problem

  \item The statement of the problem specifies the desired input/output relationship

  \item The algorithm describes a computational procedure for generating the correct output for every input instance

  \item Computers keep getting faster, but data keeps growing at an even faster rate

  \item Our algorithms must be efficient in terms of resource usage

  \item Resources can be:

    \begin{itemize}

      \item Computation time: number of instructions to execute

      \item Space: amount of physical memory required by the algorithm

      \item Other resources: network bandwidth

    \end{itemize}

  \item Analyzing an algorithm means predicting the resources that an algorithm requires

  \item Most often it  is the computational time that we want to measure

  \item Analysis of Algorithms

    \begin{itemize}

      \item Other important features of a computer program beside performance:

        \begin{itemize}

          \item Modularity

          \item Maintainability

          \item Robustness

          \item Simplicity

          \item Extensibility

          \item Reliability

          \item Readability

        \end{itemize}

    \end{itemize}

  \item Python

    \begin{itemize}

      \item Python is very intuitive, highly readable, and easy to learn

      \item Developed by Dutch programmer Guido Van Rossum in the late 1980s

      \item Python is one of the most preferred programming languages for working in data analytics and machine learning domains

      \item The most popular programming language as of March 2022

      \item Python is a powerful, high-level, interpreted, object-oriented programming language

      \item It has a simple and easy-to-use syntax

      \item Portable across different platforms and operating systems

      \item Has a rich variety of native data structures such as lists and dictionaries

      \item Python code is typically 1/5 to 1/3 the size of equivalent C or Java code

      \item There are two major versions of the python language:

        \begin{itemize}

          \item Python 2.x is legacy

          \item Python 3.x is the present and future of the language

        \end{itemize}

      \item Python 3 is not backward-compatible with Python 2

    \end{itemize}

  \item An IDE (Integrated Development Environment) provides a rich set of features that make the developer's life easier, such as:

    \begin{itemize}

      \item Debugger

      \item Code profiling

      \item Unit testing

      \item Integration with version control systems like Git

      \item An many more

    \end{itemize}

  \item Many IDEs exist for Python: PyCharm, VSCode, PyDev, Eclispde, Komodo, Spyder, etc.

  \item Categories of Programming Languages:

    \begin{enumerate}

      \item OO and Visual Language

      \item FORTRAN, C, Pascal

      \item High-Level Language

      \item Assembly Language

      \item Machine Language

      \item Hardware

    \end{enumerate}

  \item Low-level language is a programming language that provides little or no abstraction from a computer's instruction set architecture (ISA) commands or functions in the language map close to processor instructions

    \begin{itemize}

      \item Generally, this refers to either machine code or assembly language

      \item Tend to be relatively non-portable

    \end{itemize}

  \item High-level language is a more understandable and portable language in which each statement accomplishes substantial tasks

    \begin{itemize}

      \item Level of abstraction closer to problem domain

      \item Provides for productivity and portability

    \end{itemize}

  \item After compilation, a high-level language (say, C) becomes an Assembly Program

    \begin{itemize}

      \item A textual representation of instructions

      \item Human-readable format instructions

    \end{itemize}

  \item After assembly language, it becomes a Machine Program

    \begin{itemize}

      \item Binary digits (bits)

      \item Encoded instructions and data

      \item Computer-readable format instructions

    \end{itemize}

  \item Compiler is a program for converting high-level code into low-level code or binary form

  \item Assembler is a utility program for converting assembly language code into executable machine code (1's and 0's)

  \item Machine code is the only language a computer can process directly

  \item Compilers

      \begin{itemize}

        \item A compiler is a program that converts the entire source code of a programming language into executable machine code for a CPU 

        \item Compiler takes a large amount of time to analyze the entire source code but the overall execution time of the program is significantly faster 

        \item Compiler generates the error message only after scanning the whole program. Hence, debugging is comparatively hard as the error can be present anywhere in the program 

        \item Compiler generates intermediate object code, which further requires linking; hence, needs more memory 

        \item Examples: C, C++, Java, Rust, Go 

    \end{itemize} 

    \item Interpreters

      \begin{itemize}

        \item An Interpreter takes a source program and runs it line by line, translating each line as it comes to it, one statement at a time

        \item Interpreter takes less amount of time to analyze the source code, but the overall execution time of the program is slower

        \item Interpreter's debugging is easier as it continues translating the program until the first error is met

        \item No intermediate object code is generated; hence, interpreters are more memory efficient

        \item Python, Perl, Ruby, PHP, JavaScript

      \end{itemize}

\end{itemize}

\end{document}

